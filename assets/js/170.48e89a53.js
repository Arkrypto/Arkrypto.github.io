(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{1644:function(_,v,p){"use strict";p.r(v);var n=p(1),t=Object(n.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"数据结构选填"}},[_._v("数据结构选填")]),_._v(" "),v("h3",{attrs:{id:"_2017"}},[_._v("2017")]),_._v(" "),v("p",[_._v("1、算法能识别错误的输入并进行适当的处理和反应：健壮性")]),_._v(" "),v("p",[_._v("2、贪心算法不能求解：0/1背包问题（背包问题可以解决，和背包是否能装满有关）")]),_._v(" "),v("p",[_._v("3、在一个顺序储存的循环队列，队头指针指向对头元素的：前一个位置")]),_._v(" "),v("p",[_._v("4、串的子串：按顺序取出串中字符")]),_._v(" "),v("p",[_._v("5、单链表表示法的基本思想是用"),v("em",[_._v("指针")]),_._v("表示结点间的逻辑关系")]),_._v(" "),v("p",[_._v("6、除留余数法：取"),v("em",[_._v("小于等于")]),_._v("表长的最大素数")]),_._v(" "),v("p",[_._v("7、在哈希散列中，H(K1) = H(K2) 的现象称作：冲突")]),_._v(" "),v("h3",{attrs:{id:"_2018"}},[_._v("2018")]),_._v(" "),v("p",[_._v("1、串是一种特殊的线性表，其特殊性体现在：数据元素是一个字符")]),_._v(" "),v("p",[_._v("2、单循环链表，只设头指针，其入队和出队时间复杂度为：O(n)，O(n)")]),_._v(" "),v("ul",[v("li",[_._v("因为循环链表，其入队位置和出队位置总要通过头指针向后遍历，而不是简单的头删或尾插")])]),_._v(" "),v("p",[_._v("3、算法的时间复杂度取决于问题的规模和待处理数据的初态：√")]),_._v(" "),v("p",[_._v("4、栈是一种对进栈、出栈总次数做了限制的线性表：×")]),_._v(" "),v("p",[_._v("5、把散列地址不同的结点，争夺同一后记散列地址的现象称为冲突：×（散列地址"),v("strong",[_._v("相同")]),_._v("的结点争夺同一地址）")]),_._v(" "),v("p",[_._v("6、能够用分治法求解的问题往往就具有子问题重叠性质：×（最优子结构）")]),_._v(" "),v("p",[_._v("7、对于采用分块查找的数据表，要求表是：块内无序，块间有序")]),_._v(" "),v("p",[_._v("8、索引表的索引项一般形式是：【关键字，地址】")]),_._v(" "),v("p",[_._v("9、贪心算法能够求解的问题应具有：最优子结构，"),v("strong",[_._v("贪心选择")]),_._v("的性质")]),_._v(" "),v("ul",[v("li",[_._v("动态规划是：最优子结构，子问题重叠")]),_._v(" "),v("li",[_._v("贪心算法是：最优子结构，贪心选择")]),_._v(" "),v("li",[_._v("分治法是：最优子结构")])]),_._v(" "),v("h3",{attrs:{id:"_2019"}},[_._v("2019")]),_._v(" "),v("p",[_._v("1、抽象数据类型的三个组成部分不包括：数据类型")]),_._v(" "),v("ul",[v("li",[_._v("三部分为：数据对象 class，基本操作 function，数据关系 implement")])]),_._v(" "),v("p",[_._v("2、当利用顺序表存取队列时，队列最大长度为：n-1")]),_._v(" "),v("p",[_._v("3、对于 n 个顶点和 e 条边的无向图，拓扑排序时间为：n+e")]),_._v(" "),v("p",[_._v("4、关于散列表的几个说法")]),_._v(" "),v("ul",[v("li",[_._v("散列法存储的基本思想是由关键字的值直接计算出数据的存储地址：√")]),_._v(" "),v("li",[_._v("装填因子是散列表的重要参数，反映散列表的装填程度：×")]),_._v(" "),v("li",[_._v("散列表的查找效率主要取决于散列表造表时的散列函数和处理冲突的方法：√")]),_._v(" "),v("li",[_._v("散列表的结点中只包含数据元素自身的信息，不包含任何地址：×")])]),_._v(" "),v("p",[_._v("5、定义逻辑结构时可不考虑物理结构：√")]),_._v(" "),v("p",[_._v("6、循环队列的引入是为了克服溢出：×（假上溢）")]),_._v(" "),v("p",[_._v("7、对于线性表来说，定位运算在顺序表和单链表上的时间复杂度均为 O(n)：√（定位运算，及遍历查找）")]),_._v(" "),v("p",[_._v("8、任何无环的有向图，其结点都可以排在一个拓扑排序里：√（孤立的结点入度为 0，直接入拓扑就是）")]),_._v(" "),v("p",[_._v("9、若将数据结构形式定义为二元组（K,R），其中 K 是数据元素的有限集合，则 R 是 K 上：关系的有限集合")]),_._v(" "),v("p",[_._v("10、在双向链表中求某个结点的前驱，时间复杂度为：O(1)（已知该结点）")]),_._v(" "),v("p",[_._v("11、串是"),v("em",[_._v("有限")]),_._v("个字符的序列")]),_._v(" "),v("p",[_._v("12、在索引表中，若一个索引项对应数据表中的一个元素，则称此索引为：稠密索引")]),_._v(" "),v("p",[_._v("13、发生冲突的两个关键字称为散列函数的：同义词")]),_._v(" "),v("p",[_._v("14、背包问题和 0/1 背包问题都具有：最优子结构（DP和贪心都具有的性质）")]),_._v(" "),v("h3",{attrs:{id:"_2020"}},[_._v("2020")]),_._v(" "),v("p",[_._v("1、在散列法中，散列函数必须是一对一的函数：×（看岔了）")]),_._v(" "),v("p",[_._v("2、索引顺序结构和索引非顺序结构的索引表中，索引项都是按关键字顺序排列的：√")]),_._v(" "),v("p",[_._v("3、在一个具有 n 个顶点的完全有向图中，包含边：n(n-1)（一去一来）")]),_._v(" "),v("p",[_._v("4、对一个长度为 n 的任意文件进行排序，至少需要比较：nlogn 次")]),_._v(" "),v("h3",{attrs:{id:"_2021"}},[_._v("2021")]),_._v(" "),v("p",[_._v("1、用数组 A[50] 存放循环队列元素，对头 front = 13，队尾 rear = 5，则元素个数为：(rear + M -front) % M = 42")]),_._v(" "),v("p",[_._v("2、队列和栈都是操作受限的线性表，只允许在表的两端进行运算：×（栈只能一端）")]),_._v(" "),v("p",[_._v("3、设串的长度为 n，则其子串个数最多为 (1+n)n/2：×（空串也算一个子串，要加一个！！！）")]),_._v(" "),v("p",[_._v("4、给定串 S1 和 S2 的长度分别为 n 和 m，则针对 S1 和 S2 使用字串定位的布鲁特-福斯算法最好情况下的时间复杂度为：O(n+m)")]),_._v(" "),v("p",[_._v("5、假设循环单链表长度为 n，队头固定在链表表尾，若只设头指针，则入队操作时间复杂度为：O(1)（注意头指针、尾指针、链表表头、表尾的区别）")]),_._v(" "),v("p",[_._v('6、目标 T = "abccdcdccbaa"，模式 P="cdcc"，则第 '),v("em",[_._v("5")]),_._v(" 次匹配成功")]),_._v(" "),v("h2",{attrs:{id:"密码学选填"}},[_._v("密码学选填")])])}),[],!1,null,null,null);v.default=t.exports}}]);