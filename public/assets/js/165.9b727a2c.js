(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{1486:function(_,v,t){"use strict";t.r(v);var e=t(1),r=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"什么是-2fa"}},[_._v("什么是 2FA？")]),_._v(" "),v("p",[_._v("2FA，Two-Factor Authentication，即双因素认证")]),_._v(" "),v("ul",[v("li",[_._v("传统的账号密码为单重认证，如 QQ 的登录；Stream 的登录则为双因素，一重为账号密码，二为手机接收的认证码短信")])]),_._v(" "),v("p",[_._v("密码 + 某种个人物品是常见的双因素组合，如银行使用的 U 盾（一个 U 盘），在此处 U 盾 充当“某种个人物品”的作用，每位用户将配备各自的 U 盾，内置有用户的签名证书与加密证书，同时 U 盾的访问受 PIN 码保护")]),_._v(" "),v("p",[_._v("一种典型实现方案为")]),_._v(" "),v("ul",[v("li",[_._v("用户在完成口令、验证码的输入后，前端调用 USBKEY 的接口对登录请求数据进行签名，并且将该签名作为一个字段加入 HTTP 请求中")]),_._v(" "),v("li",[_._v("后端系统会部署一个签名验签服务器，接收到前端登录请求后，利用签名验签服务器完成验签，验签正确则身份鉴别通过，而后再进行密码的认证，实现双因素认证")])]),_._v(" "),v("p",[_._v("本文采用奥联的 USBKEY 以及其相对应的密码机实现 U 盾的 2FA 认证。真的不得不说，奥联给的接口简直是一坨大芬🤮，文档更是牛头不对马嘴")]),_._v(" "),v("h2",{attrs:{id:"实现"}},[_._v("实现")]),_._v(" "),v("p",[_._v("具体实现的前置工作")]),_._v(" "),v("ul",[v("li",[_._v("用户 UKEY 中所使用的签名证书需要在后端签名验签服务器中登记在案")]),_._v(" "),v("li",[_._v("UKEY 的插件环境需要用户自行下载安装")]),_._v(" "),v("li",[_._v("后端服务器对于签名验签服务器的访问需要额外的证书"),v("code",[_._v("server.cer")]),_._v("以及密码")]),_._v(" "),v("li",[_._v("需要一个倒霉蛋将 UKEY 从西安邮到秦皇岛......")])]),_._v(" "),v("h3",{attrs:{id:"签名"}},[_._v("签名")]),_._v(" "),v("p",[_._v("采用 WebSocket 形式的接口（异步回调）对前端表单数据进行 SGD_SM3_SM2 进行签名，该 UKEY 接口内部写死 SignerID 为"),v("code",[_._v('"1234567812345678"')]),_._v("（该算法默认标准 ），在后续验签时需保持一致")]),_._v(" "),v("h3",{attrs:{id:"验签"}},[_._v("验签")]),_._v(" "),v("p",[_._v("前端将原始表单数据（原文）和签名数据（密文）一同打在后端接口上，后端接收到请求后，首先根据用户名从数据库中取出用户证书，再对前端传来的原文和密文通过证书和签名验签服务器进行验证，返回"),v("code",[_._v("true/false")]),_._v("，实现一重认证")]),_._v(" "),v("p",[_._v("而后的二重认证就是传统的密码认证，不再赘述")]),_._v(" "),v("h2",{attrs:{id:"后记"}},[_._v("后记")]),_._v(" "),v("p",[_._v("关于这个方案，用户不可能随时携带 U 盾，手机才是最好的替代品。密码 + 手机就成了最佳的双因素认证方案（from 阮一峰）")]),_._v(" "),v("p",[_._v("另外，奥联的接口，谁用谁知道，无敌了")])])}),[],!1,null,null,null);v.default=r.exports}}]);