(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{1458:function(v,_,i){"use strict";i.r(_);var l=i(1),p=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"os-概述"}},[v._v("OS 概述")]),v._v(" "),_("p",[v._v("操作系统特征")]),v._v(" "),_("ul",[_("li",[v._v("并发性，记清楚了，不是并行性")]),v._v(" "),_("li",[v._v("共享性")]),v._v(" "),_("li",[v._v("虚拟性")]),v._v(" "),_("li",[v._v("异步性")])]),v._v(" "),_("p",[v._v("操作系统历程：原始操作系统 ——> 管理系统 ——> 操作系统")]),v._v(" "),_("p",[v._v("不同操作系统")]),v._v(" "),_("ul",[_("li",[v._v("批处理系统：关注吞吐量")]),v._v(" "),_("li",[v._v("分时：关注交互性")]),v._v(" "),_("li",[v._v("实时：关注及时响应（通过中断机制）")])]),v._v(" "),_("p",[v._v("微内核和宏内核：微内核的效率更低，因为需要频繁切换状态（内核态和用户态）")]),v._v(" "),_("h2",{attrs:{id:"作业管理和用户接口"}},[v._v("作业管理和用户接口")]),v._v(" "),_("p",[v._v("系统调用，中断")]),v._v(" "),_("p",[v._v("作业的调度算法")]),v._v(" "),_("ul",[_("li",[v._v("先来先：FCFS")]),v._v(" "),_("li",[v._v("短作业优先：SJF")]),v._v(" "),_("li",[v._v("相应比高者优先：相应比 = 已等待时间 / 所需 CPU 时间")])]),v._v(" "),_("p",[v._v("SPOOLing 系统")]),v._v(" "),_("ul",[_("li",[v._v("输入输出缓存区")]),v._v(" "),_("li",[v._v("输入输出井")])]),v._v(" "),_("h2",{attrs:{id:"进程管理"}},[v._v("进程管理")]),v._v(" "),_("h3",{attrs:{id:"进程调度"}},[v._v("进程调度")]),v._v(" "),_("p",[v._v("进程状态：就绪、阻塞、执行、终止")]),v._v(" "),_("p",[v._v("进程控制块：PCB")]),v._v(" "),_("p",[v._v("进程是资源分配的基本单位，线程是资源调度的基本单位")]),v._v(" "),_("p",[v._v("进程调度算法")]),v._v(" "),_("ul",[_("li",[v._v("先来先服务：FCFS")]),v._v(" "),_("li",[v._v("最短 CPU 运行期优先：SCBF")]),v._v(" "),_("li",[v._v("最高优先权：HPF，分为静态和动态、抢占式和非抢占式")]),v._v(" "),_("li",[v._v("时间片轮转：RR")]),v._v(" "),_("li",[v._v("多级反馈队列：MFQS")])]),v._v(" "),_("p",[v._v("周转时间：进程终止时间 - 进程调入时间")]),v._v(" "),_("p",[v._v("用户级线程和内核级线程：后者需要进入内核态，前者不需要")]),v._v(" "),_("p",[v._v("临界资源与临界区")]),v._v(" "),_("h3",{attrs:{id:"同步与互斥"}},[v._v("同步与互斥")]),v._v(" "),_("p",[v._v("信号量机制，P/V 操作，同步互斥设计")]),v._v(" "),_("p",[v._v("进程通信")]),v._v(" "),_("ul",[_("li",[v._v("共享内存：Redis")]),v._v(" "),_("li",[v._v("消息传递：WebSocket")]),v._v(" "),_("li",[v._v("管道传输：RabbitMQ")])]),v._v(" "),_("h3",{attrs:{id:"死锁"}},[v._v("死锁")]),v._v(" "),_("p",[v._v("死锁预防：破坏死锁产生的必要条件")]),v._v(" "),_("ul",[_("li",[v._v("破坏互斥条件：SPOOLing")]),v._v(" "),_("li",[v._v("破坏不可剥夺条件：抢夺式分配")]),v._v(" "),_("li",[v._v("破坏保持请求条件：一次性分配")]),v._v(" "),_("li",[v._v("破坏循环等待条件：给资源编号")])]),v._v(" "),_("p",[v._v("死锁避免：银行家算法")]),v._v(" "),_("p",[v._v("死锁检测：资源分配图，矩形中的圆圈表示资源，圆圈表示进程，箭头朝进程表示分配，朝资源表示请求分配，通过撤销进程来判断资源是否足够分配（若撤销了还不够，说明产生死锁）")]),v._v(" "),_("p",[v._v("死锁解除")]),v._v(" "),_("ul",[_("li",[v._v("撤销所有陷入死锁的进程：一刀切")]),v._v(" "),_("li",[v._v("逐个撤销陷入死锁中的进程：逐个抓")]),v._v(" "),_("li",[v._v("使陷入死锁中的进程逐个放弃所占有资源，直到死锁消失：注意此时并不撤销进程，只是令其放弃资源，转入阻塞队列")])]),v._v(" "),_("h2",{attrs:{id:"存储管理"}},[v._v("存储管理")]),v._v(" "),_("p",[v._v("就是内存管理")]),v._v(" "),_("p",[v._v("程序的链接、装入")]),v._v(" "),_("p",[v._v("地址重定位")]),v._v(" "),_("h3",{attrs:{id:"连续分配"}},[v._v("连续分配")]),v._v(" "),_("p",[v._v("内存连续分配存储管理")]),v._v(" "),_("ul",[_("li",[v._v("静态分配局部置换")]),v._v(" "),_("li",[v._v("动态分配全局置换")]),v._v(" "),_("li",[v._v("动态分配局部置换")])]),v._v(" "),_("p",[v._v("分区分配算法")]),v._v(" "),_("ul",[_("li",[v._v("首次适应 FF：地址升序")]),v._v(" "),_("li",[v._v("最差适应 WF：空闲区大小降序排列")]),v._v(" "),_("li",[v._v("最优适应 BF：空闲区大小升序排列（产生最多的内部碎片）")])]),v._v(" "),_("h3",{attrs:{id:"离散分配"}},[v._v("离散分配")]),v._v(" "),_("p",[v._v("分页")]),v._v(" "),_("p",[v._v("分段")]),v._v(" "),_("p",[v._v("段页式")]),v._v(" "),_("h3",{attrs:{id:"虚拟存储"}},[v._v("虚拟存储")]),v._v(" "),_("p",[v._v("程序的局部性原理")]),v._v(" "),_("p",[v._v("请求分页式存储管理")]),v._v(" "),_("p",[v._v("页面置换算法")]),v._v(" "),_("ul",[_("li",[v._v("先进先出：FIFO")]),v._v(" "),_("li",[v._v("最近最久未使用：LRU")]),v._v(" "),_("li",[v._v("最近未使用：NRU")])]),v._v(" "),_("h2",{attrs:{id:"文件管理"}},[v._v("文件管理")]),v._v(" "),_("h3",{attrs:{id:"文件"}},[v._v("文件")]),v._v(" "),_("p",[v._v("逻辑结构、物理结构")]),v._v(" "),_("p",[v._v("存储逻辑结构")]),v._v(" "),_("ul",[_("li",[v._v("连续")]),v._v(" "),_("li",[v._v("链接")]),v._v(" "),_("li",[v._v("索引")]),v._v(" "),_("li",[v._v("Hash")])]),v._v(" "),_("p",[v._v("存储物理结构")]),v._v(" "),_("ul",[_("li",[v._v("顺序存储")]),v._v(" "),_("li",[v._v("链式存储：分为隐式和显式（链接表 FAT）")]),v._v(" "),_("li",[v._v("索引存储")])]),v._v(" "),_("p",[v._v("文件控制块：FCB")]),v._v(" "),_("p",[v._v("索引节点，索引表，文件打开表，系统打开表")]),v._v(" "),_("h3",{attrs:{id:"目录管理"}},[v._v("目录管理")]),v._v(" "),_("p",[v._v("二级目录")]),v._v(" "),_("p",[v._v("树形目录")]),v._v(" "),_("h3",{attrs:{id:"磁盘管理"}},[v._v("磁盘管理")]),v._v(" "),_("p",[v._v("非空闲磁盘管理")]),v._v(" "),_("p",[v._v("空闲磁盘管理")]),v._v(" "),_("ul",[_("li",[v._v("空闲表法")]),v._v(" "),_("li",[v._v("空闲链表法")]),v._v(" "),_("li",[v._v("位示图：FAT（不允许同名文件）")]),v._v(" "),_("li",[v._v("成组链接法：UNIX")])]),v._v(" "),_("p",[v._v("可变分区存储管理")]),v._v(" "),_("p",[v._v("磁盘调度算法")]),v._v(" "),_("ul",[_("li",[v._v("先来先服务：FCFS")]),v._v(" "),_("li",[v._v("最短寻道时间优先：SSTF")]),v._v(" "),_("li",[v._v("电梯调度算法：SCAN")]),v._v(" "),_("li",[v._v("优化的电梯调度算法：C-SCAN")])]),v._v(" "),_("h2",{attrs:{id:"设备管理"}},[v._v("设备管理")]),v._v(" "),_("p",[v._v("缓冲技术")]),v._v(" "),_("ul",[_("li",[v._v("单缓冲区")]),v._v(" "),_("li",[v._v("双缓冲区")]),v._v(" "),_("li",[v._v("缓冲池")])]),v._v(" "),_("p",[v._v("计算任务最快时间，类似流水线的计算方法，着眼于当前状态到下一同一状态所经时间")]),v._v(" "),_("p",[v._v("SPOOLing 技术")]),v._v(" "),_("ul",[_("li",[v._v("输入输出井")]),v._v(" "),_("li",[v._v("输入输出缓冲区")]),v._v(" "),_("li",[v._v("输入输出进程")])]),v._v(" "),_("p",[v._v("磁盘的访问时间计算：寻道时间")]),v._v(" "),_("p",[v._v("磁盘调度算法")])])}),[],!1,null,null,null);_.default=p.exports}}]);