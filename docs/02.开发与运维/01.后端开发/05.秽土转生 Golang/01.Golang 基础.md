---
date: 2025-3-23
author: 
  name: northboat
  link: https://github.com/northboat
title: Golang 基础
permalink: /pages/48385f/
---

## 环境搭建

### Golang

镜像站下载：[All releases - The Go Programming Language](https://golang.google.cn/dl/)

测试版本环境

```go
go version
go env
```

### Goland

官网下载：[Other Versions - GoLand](https://www.jetbrains.com/go/download/other.html)

破解：[GoLand 2024.3.3 最新破解版安装教程（附激活码，至2099年~） - 犬小哈教程](https://www.quanxiaoha.com/goland-pojie/goland-pojie-202433.html)

🙌 PS：可以下个 Python Community Edition 插件，这玩意儿可以用来写 Python

### Go Module

从 Go1.13 开始，Go Module 作为 Golang 中的标准包管理器，在安装时自动启用，并附带一个默认的 GOPROXY

- GOPROXY 即为 GOPROXY 的下载源
- Go Module 通过配置文件 go.mod 进行包管理

公共 GOPROXY 是一个集中式的存储库，它缓存了大量开源的 Go 模块，这些模块可以从第三方公开访问的 VCS 项目存储库中获得

- 大多数此类 GOPROXY，比如 JFrog GoCenter，http://Goproxy.cn 都是免费提供给 Golang 开发社区的

公共 GOPROXY 的架构拓扑如下图，提供了 Go Module 的一致性以及可用性能力

<img src="./assets/v2-fbe376a40910b809278beadb50a0765a_1440w.png">

在 Go 文件中，使用 `import()` 导入包

```go
import (
    "fmt"
    "math/rand"
)
```

创建自定义包

在 `mypackage` 目录下创建 `calculation.go` 文件：

```go
package mypackage

func Add(a, b int) int {
    return a + b
}
```

在 `main.go` 中使用自定义包：

```go
import (
    "fmt"
    "mypackage"
)

func main() {
    result := mypackage.Add(3, 5)
    fmt.Println(result) // 输出: 8
}
```

注意，Go 语言中**函数（或变量、结构体等）的可见性**是由其**首字母的大小写**决定的。具体规则如下

- 首字母大写：表示该函数（或变量、结构体等）是导出的（exported），可以被其他包访问
- 首字母小写：表示该函数（或变量、结构体等）是未导出的（unexported），只能在当前包内访问

文件名其实不重要，重要的是文件夹名，因为在 Main 函数中调用时，采用的是`文件夹名.大写函数()`的形式进行调用

## 基础语法

> Golang 基础
>
> - 基础语法：变量、数据类型、控制结构（if/for/switch）、函数
> - 数据结构：数组、切片、映射（map）、指针
> - 结构体与接口：面向对象的编程方式
> - 并发编程：Goroutine、Channel、WaitGroup、Mutex
>
> 多写小项目，比如用 Go 实现一个简单的 CLI 工具；使用 `go test` 进行单元测试，熟悉测试框架

第一个 Go 程序

```go
package main
import (
	"fmt"
)

func main() {
	s := "Hello Golang!"
	fmt.Println(s)
	for i := 1; i <= 5; i++ {
		fmt.Println("i =", 100/i)
	}
}
```

### 变量与常量

变量定义

- 定义变量无需指定变量类型，同时使用`:=`进行定义
- 语句通过换行分割，不用分号（类似于 Python），但仍然使用括号，并不采用缩进来表示嵌套层级

`fmt.Printf`输出

```go
num := 4
str := "hahaha"
float := 3.14
char := 'A'
fmt.Printf("%d, %s, %f, %c\n", num, str, float, char)
fmt.Printf("%v, %v, %v, %v", num, str, float, char)
```

`%v`是通用输出，浮点数将被就近“取整”，例如上面的例子，第一次将输出`3.140000`，第二次则是`3.14`。另外，`%v`下字符将被输出为 ASCII 码

```bash
4, hahaha, 3.140000, A
4, hahaha, 3.14, 65
```

`fmt.Println`输出，用于快速调试，应该是用的最多的

- `fmt.Println` 会在每个参数之间自动插入**空格**
- 并在结尾添加**换行符**（`\n`），若不想换行，可用`Print`（`Print`不会自动添加空格）

### 控制结构

1️⃣ if 语句

Go 的 `if` 语句和 Java 类似，但条件语句不需要括号，而大括号`{}`必须存在

```go
if age > 18 {
    fmt.Println("Adult")
}
```

在`if`语句中可以定义变量，例如

```go
num := rand.Int() // 取随机数
if i := num - 3875633537609512361; i > 0 {
    fmt.Println(i, mypackage.SayHello())
} else {
    fmt.Println(i, mypackage.SayHelloAgain())
}
```

这个`i`的作用域仅在`if`域中

2️⃣ for 语句

Go 中没有 While 循环，采用 for 代替
$$
while(true)\{\}=for\{\}
$$
一个经典的 for 循环，只是在 Java 的基础上去掉了小括号

```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
```

一个死循环

```go
for{
    fmt.Println("nmsl")
}
```

一个类似于 while 的 for 循环

```go
i := 0
for i < 5 {
    fmt.Println(i)
    i++
}
```

但是注意不可以`i++ < 5`这样判断

3️⃣ switch 语句

Go 的`switch`不需要`break`，匹配成功后默认不会继续执行下一个 case，不像 Java 那样需要`break`手动跳出

```go
day := "Monday"
switch day {
case "Monday":
    fmt.Println("Start of the week")
case "Friday":
    fmt.Println("Weekend is near")
default:
    fmt.Println("Midweek")
}
fmt.Println("Start TestSwitch()!\n")
```

多值匹配，用逗号连接

```go
switch day {
case "Saturday", "Sunday":
    fmt.Println("Weekend")
default:
    fmt.Println("Weekday")
}
```

switch 后可以不接变量，而在 case 后添加布尔值，这样 switch 语句将执行第一个为 true 的 case，当作一个 if-else 语句来用

```go
score := 85
switch {
case score >= 90:
    fmt.Println("A")
case score >= 80:
    fmt.Println("B")
default:
    fmt.Println("C")
}
```

使用`fallthrough`修饰 case，那么执行完当前 case 后将继续执行下一个 case

```go
switch num := 2; num {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")
    fallthrough  // 继续执行下一个 case
case 3:
    fmt.Println("Three")
case 4:
    fmt.Println("Four")
}
```

当然，只往下执行一条，即输出会为

```sh
Two
Three
```

### 函数

> 在 Go 中，函数（Function）是**一等公民**，可以作为参数、返回值，也可以是匿名函数

函数定义，在 go 中，使用关键字`func`定义一个函数

```go
func 函数名(参数列表) (返回值列表) {
    // 函数体
}
```

根据入参和返回，有这样几种函数定义

1️⃣ 无入参无返回

```go
func sayHello() {
    fmt.Println("Hello, Go!")
}
```

2️⃣ 有入参无返回

```go
func add(x int, y int) {
    fmt.Println("Sum:", x+y)
}
```

如果多个参数类型相同，可以省略前面的类型，只写最后一个，如

```go
func hello(x, y int, name string){
    fmt.Println("Hello,", name)
    fmt.Println("Sum:", x+y)
}
```

另外，注意**参数是值传递，不会影响原变量**

3️⃣ 有返回

```go
func add(x, y int) int {
    return x + y
}
```

在小括号后定义返回类型，如这里定义返回类型为`int`

可以定义多个返回值（而不需要用数组返回）

```go
func swap(a, b int) (int, int) {
    return b, a
}
```

4️⃣ 命名返回值

我们可以在返回值列表直接定义返回变量名，从而在`return`时，可以省略掉`return`的变量，像一个无返回的函数直接`return`就行

```go
func rectangleArea(length, width int) (area int) {
    area = length * width
    return // 省略 return area
}

func main() {
    fmt.Println(rectangleArea(5, 10)) // 50
}
```

实际上，就是在定义函数的时候创建了这个返回变量，很智能的设计，适合下发开发任务 🤓，最规范的一集

5️⃣ 变长入参

- 入参列表`(numbers ...int)` 会把所有参数作为**切片**处理
- 可变参数可以和普通参数混用，但**可变参数必须放在最后**

```go
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2, 3, 4)) // 10
}
```

那么问题来了，这和我直接传一个切片有什么区别

6️⃣ 函数作为入参

```go
func operate(a, b int, op func(int, int) int) int {
    return op(a, b)
}

func main() {
    add := func(x, y int) int { return x + y }
    result := operate(3, 5, add)
    fmt.Println(result) // 8
}
```

这里的函数 op 是变化的，它可以是 add，也可以是 mul 或其他

- 这样的设计在 MyLisp 的编写中见过，内建函数的实现采用了这种形式

7️⃣ 函数作为返回

```go
func multiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    double := multiplier(2)
    fmt.Println(double(5)) // 10
}
```

在这里`double`作为一个函数变量存在，好玩捏

8️⃣ 匿名函数

即时定义并使用

```go
func main() {
    func(msg string) {
        fmt.Println(msg)
    }("Hello, Go!") // 直接调用
}
```

这是一个有入参无返回的匿名函数，执行将输出`Hello, Go!`

### 命名习惯

我们的文件夹名原则上要和包名（package 名）保持一致，即在 learning 文件夹下的所有文件都有

```go
package learning
```

而不是其他包名

一些命名习惯

- 文件命名：小写字母加下划线，例如`my_mysql_test`
- 文件夹、包命名：小写字母连接，比如`mycontrolflow`，应尽量缩小为单个单词如`flow`
- 变量命名：小写字母起头驼峰，比如`numSum := 0`
- 常量命名：大写字母加下划线，比如`KEY_NUM := 4`
- 函数、结构体、接口、方法命名：驼峰，开头大小写根据 exported 决定，比如`Add(), add()`
- 测试函数命名：Test 开头的驼峰，比如`TestAdd()`

## 数据结构

### 数组和切片

切片的定义：`[]数据类型{初始数据1, 初始数据2, ...}`

```go
nums := []int{1, 2, 3}
fnums := []float64{3.14, 2.71, 1.618}
words := []string{"Hello", "Go", "Language"}
flags := []bool{true, false, true}
data := []byte{'a', 'b', 'c'}

// 指针切片
x, y, z := 10, 20, 30
numbers := []*int{&x, &y, &z}
fmt.Println(*numbers[0], *numbers[1], *numbers[2]) // 10 20 30
```

若想定义空的切片有这样三种方法

```go
nums := make([]int, 0) // 创建一个容量为 0 的切片
nums := []int{}
var nums []int
```

推荐第一种，当然，如果有 nil 的判断，即判断`nums == nil`是否为空的操作，推荐第三种初始化（在网络编程中，例如 Json 传输，似乎第三种更有利）

切片操作：相当于定义一个 List，然后不断 add 和修改

```go
nums := make([]int, 0) // 定义一个空的切片

// 追加元素
nums = append(nums, 1)
nums = append(nums, 2, 3, 4)
fmt.Println(nums) // 输出: [1 2 3 4]

// 修改元素
nums[0] = 10
fmt.Println(nums) // 输出: [10 2 3 4]
```

可以通过内建的`len()`和`cap()`函数来获取切片的长度和容量

- `len()`返回切片的元素个数（即切片的长度）
- `cap()`返回切片的底层数组的容量（即切片所能容纳的元素个数，不一定是当前的长度

```go
nums := []int{1, 2, 3, 4}

fmt.Println("Length:", len(nums)) // 输出: Length: 4
fmt.Println("Capacity:", cap(nums)) // 输出: Capacity: 4（或更大，取决于底层数组的扩展）
```

函数返回

- 数组是定长的，在定义时必须规定长度，类似于 C 中的数组，在函数返回数组时，将复制整个数据结构进行返回，所以函数返回顺序结构时，绝大部分都是选择返回切片
- 切片是引用类型（指针），返回时不会复制底层数据，而是返回其起始指针

函数返回数组和切片

```go
// 返回切片
func getSlice() []int {
	var nums []int
	// nums := make([]int, 0)
	nums = append(nums, 1, 2, 3, 4)
	return nums
}

// 返回一个长度为 3 的整型数组，不会使用
func getArray() [3]int {
	return [3]int{1, 2, 3}
}
```

之前在说到函数接收变长参数时提到一个问题，就是：我定义一个变长参数入参和定义一个切片入参有什么区别？

```go
func Sum() int {
	return Sum1(getSlice()...)
}

func Sum1(nums ...int) int {
	sum := 0
	for _, value := range nums {
		sum += value
	}
	return sum
}

func Sum2(nums []int) int {
	sum := 0
	for _, value := range nums {
		sum += value
	}
	return sum
}
```

乍一看确实好像没有什么区别，但实际上还是有些微差别，照 GPT 的说法，可变入参似乎好于切片入参

1. 如果是`(nums ... int)`入参，入参可以为空，但切片不行，至少需要传入一个`nil`或空切片`[]int{}`（需要显式传切片）

2. 可变入参可以接受切片作为入参，用以下形式

   ```go
   nums := []int{1, 2, 3, 4}
   Sum1(nums...)  // ✅ 正确，将返回 10
   ```

简单来说：可变入参可以兼容切片，而切片无法兼容多个独立数字

使用 for 和 range 遍历切片

```go
nums := []int{1, 2, 3}
for index, value := range nums {
    fmt.Println(index, value)
}
```

当不需要使用 index 时，用`_`替代

```go
nums := []int{1, 2, 3}
sum := 0
for _, value := range nums {
    sum += value
}
fmt.Println(sum) // 输出 6
```

### 映射

map 的定义：`map[键]值{}`第一个中括号为**键**类型，之后跟**值**类型，中括号中为初始数据

```go
strMapInt := make(map[string]int)
intMapInt := make(map[int]int)
intMapStr := make(map[int]string)

var strMapInt1 map[string]int
strMapInt2 := map[string]int{}
```

定义逻辑其实和切片一样，特别是初始化空的情况，用 make 或者 var

追加元素：直接定义就行，比如对于`m := make(map[string]string)`，想要插入元素，直接用`m["nmsl"] = wdnmd`就行，他会自行判断容量自动扩容

- 太智能了，逆天

函数返回 map

```go
// 返回一个 map
func getMap() map[string]int {
    var m map[string]int
    // m := map[string]int{}
    // m := make(map[string]int)
    m["one"] = 1
    m["two"] = 2
    return m
}

// 创建函数时定义返回变量
func getMap1() (m map[string]int) {
    m["one"] = 1
    m["two"] = 2
    return
}
```

使用 for 和 range 遍历映射

```go
m := map[string]int{"a": 1, "b": 2}
for k, v := range m {
    fmt.Println(k, v)
}
```

其他的遍历，两数之和

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for index, val := range nums{
        if prevIndex, prevVal := m[target-val]; prevVal{
            return []int{prevIndex, index}
        }
        m[val] = index
    }
    return nil
}
```

重点是第四行的 if 语句，这句到底干了什么

```go
if prevIndex, prevVal := m[target-val]; prevVal{}
```

我们只需要明确，`m[target-val]`到底返回的是什么，其实是两个值，分别是索引和值内容，if 最后的`prevVal`实际上就是在判断这个索引下到底存不存在内容

信息量是否有点大，我糙你的，实际上等价于

```go
for index, val := range nums{
    preIndex, preVal := m[target-val]
    if preVal{
        return []int{preIndex, index}
    }
    m[val] = index
}
```

这和 if 语句里面能进行变量短声明也有关，极大的压缩了编写

### 结构体

面向对象编程：封装、继承、多态

### 接口

结构体输出：通过`Printf`格式化`%+v`进行结构体值输出（否则会输出地址）

```go
fmt.Printf("%+v", myStruct)
```

## 并发编程

### Go 协程和 Channel



### Select 语句

`select`类似`switch`，但用于处理`channel`的并发通信

- `select`会等待某个`case`变为可用（即`channel`有数据）
- `default`分支可选，如果所有`case`都阻塞，`default`立即执行

```go
ch1 := make(chan string)
ch2 := make(chan string)

go func() {
    ch1 <- "Hello"
}()

go func() {
    ch2 <- "World"
}()

select {
case msg1 := <-ch1:
    fmt.Println("Received", msg1)
case msg2 := <-ch2:
    fmt.Println("Received", msg2)
default:
    fmt.Println("No message received")
}
```
