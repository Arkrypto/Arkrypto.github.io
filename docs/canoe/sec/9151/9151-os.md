---
title: 操作系统 - 9151
date: 2024-3-7
---

## 概述

操作系统特征

- 并发性，记清楚了，不是并行性
- 共享性
- 虚拟性
- 异步性

操作系统历程：原始操作系统 ——> 管理系统 ——> 操作系统

不同操作系统

- 批处理系统：关注吞吐量
- 分时：关注交互性
- 实时：关注及时响应（通过中断机制）

微内核和宏内核：微内核的效率更低，因为需要频繁切换状态（内核态和用户态）

## 处理机管理

### 作业管理和用户接口

系统调用，中断

作业的调度算法

- 先来先：FCFS
- 短作业优先：SJF
- 相应比高者优先：相应比 = 已等待时间 / 所需 CPU 时间

SPOOLing 系统

- 输入输出缓存区
- 输入输出井

### 进程调度

进程状态：就绪、阻塞、执行、终止

进程控制块：PCB

进程是资源分配的基本单位，线程是资源调度的基本单位

进程调度算法

- 先来先服务：FCFS
- 最短 CPU 运行期优先：SCBF
- 最高优先权：HPF，分为静态和动态、抢占式和非抢占式
- 时间片轮转：RR
- 多级反馈队列：MFQS

周转时间：进程终止时间 - 进程调入时间

用户级线程和内核级线程：后者需要进入内核态，前者不需要

临界资源与临界区

### 同步与互斥

信号量机制，P/V 操作，同步互斥设计

进程通信

- 共享内存：Redis
- 消息传递：WebSocket
- 管道传输：RabbitMQ

生产-消费者问题：通过一个 mutex = 1 控制缓冲区的访问权，通过 full = 0，empty = n 来控制缓冲区中资源的数量和空闲的位置

在生产前

1. 先要 wait(empty) 判断是否有空位
2. 然后再 wait(mutex) 拿取缓冲区访问权，singal(full) 将资源放入缓冲区，填满一个空位（full + 1）
3. 最后别忘记释放缓冲区访问权 singal(mutex)

消费同理

1. 先 wait(full) 判断是否有资源可拿
2. 再 wait(mutex) 拿取缓冲区访问权，拿取资源 singal(empty)，空出一个空位
3. 最后释放缓冲区 singal(mutex)

在有多个生产、消费者时，或有生产消费链时，要使用多个 mutex 去控制每一个缓冲区的访问权，多个 full 和 empty 去控制缓冲区的资源存储情况

读写互斥问题：通过 count = 0 来记录当前读者数量，通过 rw 来控制读写权限，通过 mutex 来控制操作 count 的权限

- 必须用 mutex 给 count 的操作（+1/-1）上锁，不然多个读者同时访问时将出现脏读

基本的读者进程

```c
read(){
    // 要读了，要修改 count++ 了，事先要拿 count 的访问权
    P(mutex);
    if(count == 0){ // 当为第一个读者，要等待读写权限
        P(rw)
    }
    count++;
    V(mutex)
    reading();
    // 读完了，要修改 count-- 了，事先拿 count 访问权
    P(mutex);
    count--;
    if(count == 0){
        V(rw) // 当没有读者，释放读写权限
    }
    V(mutex)
}
```

基本写者进程，就是这么简单

```c
write(){
    P(rw);
    writting();
    V(rw);
}
```

这有很多变式，如单向路口，同时仅限一方通行：此时需要设置两个 count 去记录两批读者的数量，两个 mutex 来给两个 count 上锁，用一个 pass 信号量给“通行”这一操作上锁（即一方通行时，另一方被 pass 锁上）

哲学家进食问题（一个圆桌）：通过一组信号量控制哲学家拿筷子的操作，为了避免哲学家同时拿左手筷子导致死锁，采用给哲学家拿左右两只筷子（两个连续操作）上锁的方式

```c
Semagore stick[1,1,1,1,1];
Semagore mutex = 1; // 给拿两只筷子操作上锁
void eat(int i){ // 第 i 个哲学家进食
    P(mutex);
    P(stick[i] && stick[(i+1)%5]);
    eatting;
    V(stick[i] && stick[(i+1)%5]);
    V(mutex);
}
```

这样每次保证只有一个哲学家进食，不可能出现有其他哲学家抢他筷子的情况发生（会导致忙等，但不失为一种同步互斥方案）

### 死锁

死锁预防：破坏死锁产生的必要条件

- 破坏互斥条件：SPOOLing
- 破坏不可剥夺条件：抢夺式分配
- 破坏保持请求条件：一次性分配
- 破坏循环等待条件：给资源编号

死锁避免：银行家算法

死锁检测：资源分配图，矩形中的圆圈表示资源，圆圈表示进程，箭头朝进程表示分配，朝资源表示请求分配，通过撤销进程来判断资源是否足够分配（若撤销了还不够，说明产生死锁）

死锁解除

- 撤销所有陷入死锁的进程：一刀切
- 逐个撤销陷入死锁中的进程：逐个抓
- 使陷入死锁中的进程逐个放弃所占有资源，直到死锁消失：注意此时并不撤销进程，只是令其放弃资源，转入阻塞队列

## 存储管理

就是内存管理

程序的链接、装入

地址重定位

### 连续分配

内存连续分配存储管理

- 静态分配局部置换
- 动态分配全局置换
- 动态分配局部置换

分区分配算法

- 首次适应 FF：地址升序
- 最差适应 WF：空闲区大小降序排列
- 最优适应 BF：空闲区大小升序排列（产生最多的内部碎片）

### 离散分配

分页

分段

段页式

### 虚拟存储

程序的局部性原理

请求分页式存储管理

页面置换算法

- 先进先出：FIFO
- 最近最久未使用：LRU
- 最近未使用：NRU

## 文件管理

### 文件

逻辑结构、物理结构

存储逻辑结构

- 连续
- 链接
- 索引
- Hash

存储物理结构

- 顺序存储
- 链式存储：分为隐式和显式（链接表 FAT）
- 索引存储

文件控制块：FCB

索引节点，索引表，文件打开表，系统打开表

### 目录管理

二级目录

树形目录

### 磁盘管理

非空闲磁盘管理

空闲磁盘管理

- 空闲表法
- 空闲链表法
- 位示图：FAT（不允许同名文件）
- 成组链接法：UNIX

可变分区存储管理

磁盘调度算法

- 先来先服务：FCFS
- 最短寻道时间优先：SSTF
- 电梯调度算法：SCAN
- 优化的电梯调度算法：C-SCAN

## 设备管理

缓冲技术

- 单缓冲区
- 双缓冲区
- 缓冲池

计算任务最快时间，类似流水线的计算方法，着眼于当前状态到下一同一状态所经时间

SPOOLing 技术

- 输入输出井
- 输入输出缓冲区
- 输入输出进程

磁盘的访问时间计算：寻道时间

磁盘调度算法
